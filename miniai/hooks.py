# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/#hooks.ipynb.

# %% auto 0
__all__ = ['set_seed', 'get_hist', 'get_dead_ratio', 'Hook', 'Hooks', 'append_stats']

# %% ../nbs/#hooks.ipynb 1
import torch, numpy as np, pandas as pd, matplotlib.pyplot as plt, matplotlib as mpl
import fastcore.all as fc
from functools import partial

from .plotting import *
from .learner import *
from .callbacks import to_cpu

# %% ../nbs/#hooks.ipynb 9
def set_seed(seed, deterministic=False):
    torch.use_deterministic_algorithms(deterministic)
    torch.manual_seed(seed)
    np.random.seed(seed)
    random.seed(seed)

# %% ../nbs/#hooks.ipynb 10
def get_hist(hook, rng=None):
    """rng: tuple (i1, i2), which tells the range of iterations from which we get stats"""
    if rng is None: return torch.flip(torch.stack(hook.stats[2]).T, [0]).log1p()
    return torch.flip(torch.stack(hook.stats[2][rng[0]:rng[1]]).T, [0]).log1p()
def get_dead_ratio(hook, rng=None):
    """rng: tuple (i1, i2), which tells the range of iterations from which we get stats"""
    h = torch.stack(hook.stats[2]) if rng is None else torch.stack(hook.stats[2][rng[0]:rng[1]])
    res = h[:, 0]/(h[:, 1:].sum(1))
    return res

# %% ../nbs/#hooks.ipynb 11
class Hook:
    def __init__(self, layer, f): self.hook = layer.register_forward_hook(partial(f, self))
    def remove(self): self.hook.remove()
    def __del__(self): self.remove()

class Hooks(list):
    def __init__(self, layers, f, layers_names=None): 
        super().__init__([Hook(l, f) for l in layers])
        self.layers_names = [type(l).__name__ for l in layers] if layers_names is None else layers_names
    def __enter__(self, *args):
        return self
    def __exit__(self, *args):
        self.remove()
    def __delitem__(self, i):
        super().__delitem__(i)
    def remove(self):
        for h in self: h.remove()
    
    def plot_means_stds(self, rng=None):
        """rng: tuple (i1, i2), which tells the range of iterations from which we get stats"""
        fig, ax = subplots(nrows=1, ncols=2, imsize=(5, 4))
        for hook in self:
            ax[0].plot(hook.stats[0] if rng is None else hook.stats[0][rng[0]:rng[1]])
            ax[1].plot(hook.stats[1] if rng is None else hook.stats[1][rng[0]:rng[1]])
        plt.legend(range(len(self)))
        ax[0].set_title('Means'); ax[1].set_title('Stds')
        plt.tight_layout(); plt.show()
    def plot_acts(self, ls=None, rng=None):
        """ls: list of layers names
           rng: tuple (i1, i2), which tells the range of iterations from which we get stats"""
        if ls is None: ls = list(range(len(self)))
        show_images([get_hist(self[l], rng) for l in ls], [f'{l}_{self.layers_names[l]}' for l in ls], imsize=(3, 2), cmap='viridis')
        plt.tight_layout(); plt.show()
    def plot_dead_charts(self, ls=None, rng=None):
        """ls: list of layers names
           rng: tuple (i1, i2), which tells the range of iterations from which we get stats"""
        if ls is None: ls = list(range(len(self)))
        fig, ax = subplots(len(ls), imsize=(3, 2))
        for l in ls:
            ax[l].plot(get_dead_ratio(self[l], rng)); ax[l].set_title(f'{l}_{self.layers_names[l]}')
        plt.tight_layout(); plt.show()

# %% ../nbs/#hooks.ipynb 12
def append_stats(hook, mod, inp, out):
    if not hasattr(hook, 'stats'): hook.stats = [[], [], []]
    acts = to_cpu(out)
    hook.stats[0].append(acts.mean())
    hook.stats[1].append(acts.std())
    hook.stats[2].append(acts.abs().histc(40, 0, 10))
